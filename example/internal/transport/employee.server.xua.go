// Code generated by "xua server" from example/employee.go; DO NOT EDIT.
package transport

import (
	"encoding/json"
	"fmt"
	"net/http"
	"strconv"

	"github.com/rs/zerolog"

	"github.com/a-tho/grad-proj/example/internal"
)

type employeeStorageREST struct {
	log zerolog.Logger

	svc employee.EmployeeStorage

	create EmployeeStorageCreate
	read   EmployeeStorageRead
	update EmployeeStorageUpdate
	delete EmployeeStorageDelete
}

func (s *Server) InitEmployeeStorageServer(svc employee.EmployeeStorage) {
	s.employeeStorageREST = &employeeStorageREST{
		log:    s.log,
		svc:    svc,
		create: svc.Create,
		read:   svc.Read,
		update: svc.Update,
		delete: svc.Delete,
	}

	s.AddRoutesEmployeeStorage()
}

func (s *Server) AddRoutesEmployeeStorage() {
	s.Mux.Post("/api/v1/employee/create", s.employeeStorageREST.serveCreate)
	s.Mux.Get("/api/v1/employee/read", s.employeeStorageREST.serveRead)
	s.Mux.Patch("/api/v1/employee/update", s.employeeStorageREST.serveUpdate)
	s.Mux.Delete("/api/v1/employee/delete", s.employeeStorageREST.serveDelete)
}

func (tr *employeeStorageREST) serveCreate(w http.ResponseWriter, r *http.Request) {
	var (
		err         error
		successCode = 200
	)

	request := struct {
		Name      string `json:"name"`
		UserAgent string `json:"userAgent"`
		Bio       string `json:"bio"`
	}{}

	if err = json.NewDecoder(r.Body).Decode(&request); err != nil {
		err = fmt.Errorf("failed to decode request body: %w", err)
		tr.writeResponse(w, err.Error(), http.StatusBadRequest)
		return
	}

	if cookie, err := r.Cookie("x-name"); err == nil {
		request.Name = cookie.Value
	}

	if headerVals, ok := r.Header["User-Agent"]; ok {
		request.UserAgent = headerVals[0]
	}

	response := struct {
		Id int `json:"id"`
	}{}

	if response.Id, err = tr.create(r.Context(), request.Name, request.UserAgent, request.Bio); err != nil {
		tr.writeResponse(w, err.Error(), http.StatusInternalServerError)
		return
	}

	tr.writeResponse(w, response, successCode)
}

func (tr *employeeStorageREST) serveRead(w http.ResponseWriter, r *http.Request) {
	var (
		err         error
		successCode = 200
	)

	request := struct {
		Id int `json:"id"`
	}{}

	queryVals := r.URL.Query()
	if idRaw := queryVals.Get("id"); idRaw != "" {
		id, err := strconv.Atoi(idRaw)
		if err != nil {
			err = fmt.Errorf("failed to decode query arguments (id): %w", err)
			tr.writeResponse(w, err.Error(), http.StatusBadRequest)
			return
		}
		request.Id = id
	}

	response := struct {
		Employee employee.Employee `json:"employee"`
	}{}

	if response.Employee, err = tr.read(r.Context(), request.Id); err != nil {
		tr.writeResponse(w, err.Error(), http.StatusInternalServerError)
		return
	}

	tr.writeResponse(w, response, successCode)
}

func (tr *employeeStorageREST) serveUpdate(w http.ResponseWriter, r *http.Request) {
	var (
		err         error
		successCode = 204
	)

	request := struct {
		Id           int    `json:"id"`
		VacationDays int    `json:"vacationDays"`
		Bio          string `json:"bio"`
	}{}

	if err = json.NewDecoder(r.Body).Decode(&request); err != nil {
		err = fmt.Errorf("failed to decode request body: %w", err)
		tr.writeResponse(w, err.Error(), http.StatusBadRequest)
		return
	}

	queryVals := r.URL.Query()
	if idRaw := queryVals.Get("id"); idRaw != "" {
		id, err := strconv.Atoi(idRaw)
		if err != nil {
			err = fmt.Errorf("failed to decode query arguments (id): %w", err)
			tr.writeResponse(w, err.Error(), http.StatusBadRequest)
			return
		}
		request.Id = id
	}
	if vacationDaysRaw := queryVals.Get("vacationDays"); vacationDaysRaw != "" {
		vacationDays, err := strconv.Atoi(vacationDaysRaw)
		if err != nil {
			err = fmt.Errorf("failed to decode query arguments (vacationDays): %w", err)
			tr.writeResponse(w, err.Error(), http.StatusBadRequest)
			return
		}
		request.VacationDays = vacationDays
	}

	if err = tr.update(r.Context(), request.Id, request.VacationDays, request.Bio); err != nil {
		tr.writeResponse(w, err.Error(), http.StatusInternalServerError)
		return
	}

	tr.writeResponse(w, nil, successCode)
}

func (tr *employeeStorageREST) serveDelete(w http.ResponseWriter, r *http.Request) {
	var (
		err         error
		successCode = 204
	)

	request := struct {
		Id int `json:"id"`
	}{}

	queryVals := r.URL.Query()
	if idRaw := queryVals.Get("id"); idRaw != "" {
		id, err := strconv.Atoi(idRaw)
		if err != nil {
			tr.writeResponse(w, nil, http.StatusBadRequest)
			return
		}
		request.Id = id
	}

	if err = tr.delete(r.Context(), request.Id); err != nil {
		tr.writeResponse(w, err.Error(), http.StatusInternalServerError)
		return
	}

	tr.writeResponse(w, nil, successCode)
}

func (tr *employeeStorageREST) writeResponse(w http.ResponseWriter, respBody any, code int) {
	w.Header().Add("Content-Type", "application/json")
	w.WriteHeader(code)
	if respBody != nil {
		if err := json.NewEncoder(w).Encode(respBody); err != nil {
			tr.log.Error().Err(err).Str("body", fmt.Sprintf("%+v", respBody)).Msg("failed to write into response body")
		}
	} else {
		tr.log.Info().Msg("no body to send in response")
	}
}
